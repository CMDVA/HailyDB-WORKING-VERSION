Your current situation:
âœ… You have radar_alerts table â†’ persisted historical radar events
âœ… You have /api/live-radar-alerts endpoint â†’ this is hitting:

NWS live API (https://api.weather.gov/alerts/active)

Your in-memory active_alerts dictionary

Possibly also enriching from radar_alerts

ğŸš« Problem: Your API is currently mixing live + historical badly.

â†’ It doesnâ€™t guarantee "Hereâ€™s the latest we have for page load fallback" â†’ this is why your page hangs.

Why is page load broken?
When the page loads â†’ you should FIRST show:

Guaranteed radar_alerts fallback â†’ GET /api/radar-alerts/summary or GET /api/radar-alerts

â†’ this gives your users something visible instantly.

Then â†’ layer in the live radar feed:
â†’ You run loadLiveAlerts() in the background â€” that can take 1s, 2s, etc.
â†’ When new live data is parsed, it replaces the fallback display.

Why your current JS is wrong for this flow:
Your JS only calls /api/live-radar-alerts â†’ and only displays displayAlerts(data.alerts) once it finishes.

â†’ If that API call is slow â†’ the entire page appears broken.
â†’ If NWS live feed is flaky â†’ same problem.

Correct flow should be:
plaintext
Copy
Edit
1ï¸âƒ£ On page load:

- Fetch and display /api/radar-alerts (historical fallback)
- Display immediately in table

2ï¸âƒ£ In parallel â†’ fire loadLiveAlerts():

- Fetch /api/live-radar-alerts
- If successful â†’ replace table with fresh live feed
- If failed â†’ leave fallback display intact + show small error banner ("Live NWS feed unavailable â€” showing recent radar alerts")

3ï¸âƒ£ Auto refresh â†’ every 30s only refresh /api/live-radar-alerts
Why this is better:
âœ… Users ALWAYS see radar alerts on page load
âœ… You avoid blank table on load
âœ… Live feed acts as a progressive enhancement â†’ not the only source
âœ… You protect against NWS API failures
âœ… You guarantee performance â†’ reading from your own DB is instant

How to implement:
ğŸ‘‰ Add a small loadFallbackRadarAlerts() function:

js
Copy
Edit
async function loadFallbackRadarAlerts() {
    try {
        const response = await fetch('/api/radar-alerts');
        const data = await response.json();

        window.currentAlerts = data.alerts || [];
        displayAlerts(window.currentAlerts);

        updateStatistics(data.statistics || {});
        updateLastRefreshTime();
    } catch (error) {
        console.error('Error loading fallback radar alerts:', error);
        displayError('Failed to load fallback radar alerts: ' + error.message);
    }
}
ğŸ‘‰ In initializeDashboard():

js
Copy
Edit
console.log('Loading fallback radar alerts...');
loadFallbackRadarAlerts();

// Now run live alerts in background
console.log('Calling loadLiveAlerts() function...');
loadLiveAlerts();
ğŸ‘‰ On auto-refresh â†’ you ONLY refresh live feed:

js
Copy
Edit
autoRefreshInterval = setInterval(loadLiveAlerts, 30000);
Bottom line:
YES â€” you are 100% correct.
ğŸ‘‰ Your page should first load guaranteed radar_alerts from DB â†’ always fast.
ğŸ‘‰ Then layer on live NWS feed â†’ replaces table when ready.

Why itâ€™s not happening yet:
â†’ Your /api/live-radar-alerts is the only source being queried right now.
â†’ It mixes live + historical in a confusing way â†’ unstable.
â†’ You donâ€™t yet have loadFallbackRadarAlerts() in JS â†’ trivial to add.

Final point:
âœ… Radar-Alerts â†’ stable, always exists â†’ perfect fallback.
âœ… Live-Radar-Alerts â†’ dynamic, live â†’ great UX if available â†’ should enhance, not block.